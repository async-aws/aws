#!/usr/bin/env php
<?php

/**
 * This script aims to simplify the release process of AsyncAws components
 * Unless you are a maintainer of AsyncAws, their is nothing interesting in there.
 *
 * This script will search for components to release (based on change log and will)
 * - Find the next version
 * - Update the CHANGELOG (adds a new `## x.y.z` section for pending changes)
 * - Generate the list of commands to run
 *
 * Usage:
 * 1. run the script without argument. ie. `./release`
 * 2. copy the output and keep it for later
 * 3. open a PR for the changes generated by the script => review => merge the PR
 * 4. ⚠️ ASSERT the splitter ran successfully!! ⚠️
 * 5. run the commands generated by the step 2.
 *
 * @internal
 */

use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Finder\Finder;

if (!file_exists(__DIR__ . '/vendor/autoload.php')) {
    echo "Run `composer install` before you run the `generate` script.\n";
    exit(1);
}

require __DIR__ . '/vendor/autoload.php';

function dumpFile(string $filename, $content): void
{
    static $filesystem;
    if (!$filesystem) {
        $filesystem = new Filesystem();
    }

    $filesystem->dumpFile($filename, $content);
}
function getChangeLogs(): iterable
{
    $finder = (new Finder())
        ->in(__DIR__ . '/src')
        ->name('CHANGELOG.md');

    /** @var \SplFileInfo $file */
    foreach ($finder as $file) {
        yield $file->getRealPath();
    }
}

function getNextVersion(string $changelogPath): ?string
{
    $lines = explode("\n", file_get_contents($changelogPath));
    $started = false;
    $level = 3; // 0=major, 1=minor, 2=patch
    $lastVersion = null;
    if ('## NOT RELEASED' !== $lines[2]) {
        throw new \Exception(sprintf('The "%s" changelog file does not contain the "## NOT RELEASED" section', $changelogPath));
    }
    foreach ($lines as $line) {
        if (!$started) {
            if ('## NOT RELEASED' === $line) {
                $started = true;
            }

            continue;
        }
        if (!$line || '#' !== $line[0]) {
            continue;
        }
        if ('### BC-BREAK' === $line || '### Removed' === $line) {
            $level = 0;

            continue;
        }
        if ('### Added' === $line || '### Deprecated' === $line) {
            $level = min($level, 1);

            continue;
        }
        if ('### Changed' === $line || '### Fixed' === $line || '### Security' === $line) {
            $level = min($level, 2);

            continue;
        }

        if (0 === strpos($line, '## ')) {
            $lastVersion = substr($line, 3);

            break;
        }
    }
    if (!$started) {
        throw new \Exception(sprintf('The "%s" changelog file does not contain the "## NOT RELEASED" section', $changelogPath));
    }
    if ($level > 2) {
        return null;
    }
    if (!$lastVersion) {
        throw new \Exception(sprintf('The "%s" changelog file does not contain a previous version', $changelogPath));
    }
    if (!preg_match('/^\d+\.\d+\.\d+$/', $lastVersion)) {
        throw new \Exception(sprintf('The "%s" changelog file does not contain a valid previous version', $changelogPath));
    }

    $parts = explode('.', $lastVersion);
    if (0 === (int) $parts[0]) {
        $level = min(2, $level + 1);
    }
    $parts[$level] = (int) $parts[$level] + 1;
    for ($i = $level + 1; $i < 3; ++$i) {
        $parts[$i] = 0;
    }

    return implode('.', $parts);
}

function updateChangelog(string $changelogPath, string $version): void
{
    $lines = explode("\n", file_get_contents($changelogPath));
    if ('## NOT RELEASED' !== $lines[2]) {
        throw new \Exception(sprintf('The "%s" changelog file does not contain the "## NOT RELEASED" section', $changelogPath));
    }
    $lines[2] = '## NOT RELEASED' . "\n\n## " . $version;

    dumpFile($changelogPath, implode("\n", $lines));
}

function generateReleaseCommands(string $changelogPath, string $version): void
{
    $composerPath = \dirname($changelogPath) . '/composer.json';
    if (!is_file($composerPath)) {
        throw new \Exception(sprintf('The "%s" changelog file does not sibling composer.json', $changelogPath));
    }
    $composer = json_decode(file_get_contents($composerPath), true, \JSON_THROW_ON_ERROR);
    if (!$composer) {
        throw new \Exception(sprintf('The "%s" composer file is not valid', $composerPath));
    }
    if (!isset($composer['name'])) {
        throw new \Exception(sprintf('The "%s" composer file does not contains the "name" section', $composerPath));
    }

    $repo = $composer['name'];
    $command = sprintf('gh release create %s --title "Release %s" --notes "See [change log](CHANGELOG.md) for changes." --latest --target master --repo %s', $version, $version, $repo);
    dump($command);
}

function release(string $changelogPath): void
{
    $version = getNextVersion($changelogPath);
    if (!$version) {
        return;
    }

    updateChangelog($changelogPath, $version);
    generateReleaseCommands($changelogPath, $version);
}

foreach (getChangeLogs() as $changeLog) {
    release($changeLog);
}
